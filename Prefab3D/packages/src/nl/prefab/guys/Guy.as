//Prefab3D. www.closier.nl/prefab .  Fabrice Closier 2012package nl.prefab.guys{	import nl.prefab.guys.IGuy;	import nl.prefab.guys.data.PropertyData;	import nl.prefab.guys.data.Target;	import nl.prefab.guys.data.Guys;	import nl.prefab.guys.data.Equations;	import nl.prefab.guys.events.GuyEvent;		import flash.utils.getTimer;	import flash.utils.Dictionary;	import flash.events.EventDispatcher;		public class Guy extends EventDispatcher implements IGuy {				private var _id:String;		private var _type:String;		private var _alterVar:Boolean;		private var _properties:Vector.<PropertyData>;		private var _targets:Vector.<Target>;		private var _chain:Boolean;		private var _chainLoop:Boolean;		private var _active:Boolean;		 		public function Guy(idValue:String, typeValue:String, alterVar:Boolean){			_id = idValue;			_type = typeValue;			_alterVar = alterVar;			_properties = new Vector.<PropertyData>();			_targets = new Vector.<Target>();						Guys.register(this);		}		 		public function get id():String		{			return _id;		}				public function get type():String		{			return _type;		}				public function set chain(b:Boolean):void		{			_chain = b;			active = true;		}				public function get chain():Boolean		{			return Boolean(_chain && _properties.length>1);		}				public function set chainLoop(b:Boolean):void		{			_chainLoop = b;			active = true;		}				public function get chainLoop():Boolean		{			return _chainLoop;		}				public function set active(b:Boolean):void		{			_active = b;						if(b && _chain){				resetChain();			}						if(b && _properties.length>0){				_properties[0].active = true;								_properties[0].state = 1;				_properties[0].destTime = 0;								activateAllproperties();			}		}				public function get active():Boolean		{			return _active;		}				public function get properties():Vector.<PropertyData>		{			return _properties;		}				public function getProperty(propertyName:String):Vector.<PropertyData>		{			var propertyData:Vector.<PropertyData> = new Vector.<PropertyData>();						for(var i:uint = 0;i<_properties.length;++i)				if(_properties[i].name == propertyName) propertyData.push(_properties[i]);			 			return propertyData;		}		 		public function addPropertyData(propertyData:PropertyData):void		{			_properties.push(propertyData);						if(_alterVar)				addPropertyToTargets(propertyData);						if(chain && _properties.length>1) propertyData.active = false;								}				public function removePropertyData(propertyData:PropertyData):void		{			for(var i:uint = 0;i<_properties.length;++i){				if(_properties[i] == propertyData){					removePropertyToTargets(_properties[i]);					_properties[i] = null;					_properties.splice(i,1);					break;				}			}		}				public function resetChain():void		{			if(_properties.length == 0) return;						_properties[0].active = chain;						if(_properties.length >1){				for(var i:uint = 1;i<_properties.length;++i){					_properties[i].active = false;				}			}						dispatchGuyEvent(GuyEvent.GUY_UPDATE);		}				//targets		public function register(obj:Object):void		{			if(validate(obj)){				var target:Target = new Target();				target.object = obj;				target.originalSettings = new Vector.<Object>();				var prop:Object;				var dic:Dictionary = new Dictionary();				var propertyName:String;				if(_alterVar){										for(var i:uint = 0;i<_properties.length;++i){						prop = {};						propertyName = _properties[i].name;						if(!dic[propertyName]){							dic[propertyName] = 1;							prop.name = propertyName;							prop.value = obj[propertyName];						} else {							prop.duplicate = true;						}						target.originalSettings[i] = prop;					}									} else if(obj.transform){										prop = {};					prop.name = "transform";					prop.value = obj.transform.clone();					target.originalSettings[0] = prop;				}						 		_targets.push(target);								dic = null;			}		}		 		public function get targets():Vector.<Target>		{			return _targets;		}				public function unregister(o:Object, restoreProperties:Boolean = true):void		{			var j:uint;			for(var i:uint = 0;i<_targets.length;++i){				if(_targets[i].object == o){										if(restoreProperties)						restoreTarget(_targets[i]);										if(_targets[i].originalSettings){												for (j=0;j<_targets[i].originalSettings.length;++j){							if(_targets[i].originalSettings[j].transform)								_targets[i].originalSettings[j].transform = null;															_targets[i].originalSettings[j] = null;						}						_targets[i].originalSettings = null;					}					_targets.splice(i,1);										break;				}			}		}				//restore all original values of all affected objects		public function restore():void		{			for(var i:uint = 0;i<_targets.length;++i)				restoreTarget(_targets[i]);						if(chain) resetChain();		}		 		//methods for tweening propertydata objects		public function getEasingMethodFromIndex(index:uint):Function		{			return Equations.getEaseMethodFromIndex(index);		}				public function getEasingMethodIndex(method:Function):uint		{			return Equations.getEaseMethodIndex(method);		}				public function get easeMethodsNames():Vector.<String>		{			return Equations.easeMethodsNames;		}		 		//ment for overrides		public function dispose(destroy:Boolean = false):void		{			for(var i:uint = 0;i<_properties.length;++i)				removePropertyData(_properties[i]);						removeFromRegister(destroy);		}				public function update():void		{			throw new Error("update method must be overrided");		}				public function clone():IGuy		{			throw new Error("clone method must be overrided");		}				public static function getUniqueID(identifier:String = ""):String		{			return identifier+Math.floor(Math.random()*getTimer());		}		  		///checking if target already applied		private function validate(o:Object):Boolean		{			 for(var i:uint = 0;i<_targets.length;++i)				if(_targets[i].object == o) return false;						return true;		}				private function restoreTarget(t:Target):void		{			var obj:Object = t.object;			for(var i:uint = 0;i<t.originalSettings.length;++i){				if(t.originalSettings[i].duplicate) continue;				obj[t.originalSettings[i].name] = t.originalSettings[i].value;			}		}				public function updateOriginalSettings(propertyData:PropertyData, newPropertyName:String):void		{			var propName:String = propertyData.name;			var t:Target;			var j:uint;			for(var i:uint = 0;i<_targets.length;++i){				t = _targets[i];				for(j = 0;j<t.originalSettings.length;++j){					if(t.originalSettings[j].duplicate) continue;					if(t.originalSettings[j].name == propName){						t.originalSettings[j].name = newPropertyName;						t.originalSettings[j].value = t.object[newPropertyName];					}				}			}		}				private function removePropertyToTargets(propertyData:PropertyData):void		{			var propName:String = propertyData.name;			var t:Target;			var j:uint;			for(var i:uint = 0;i<_targets.length;++i){				t = _targets[i];				for(j = 0;j<t.originalSettings.length;++j){					if(t.originalSettings[j].name == propName){												if(!t.originalSettings[j].duplicate)							t.object[t.originalSettings[j].name] = t.originalSettings[j].value;													t.originalSettings.splice(j,1);						j--;					}				}			}						if(chain && propertyData.active)				resetChain();		}		 		private function addPropertyToTargets(propertyData:PropertyData):void		{			var propName:String = propertyData.name;			var t:Target;			var prop:Object;			for(var i:uint = 0;i<_targets.length;++i){				t = _targets[i];				prop = {};				prop.propertyID = propertyData.uniqueID;				prop.name = propName;				prop.value = t.object[propName];				t.originalSettings.push(prop);			}		}				private function activateAllproperties():void		{			if(_properties.length >0)				for(var i:uint = 0;i<_properties.length;++i)					_properties[i].active = true;						}				//events		protected function dispatchGuyEvent(type:String, property:PropertyData = null):void		{			var ge:GuyEvent = new GuyEvent(type);			ge.guyID = _id;						if(property)				ge.propertyData = property;					dispatchEvent(ge);		}				//internally called on dispose		protected function removeFromRegister(destroy:Boolean = false):void		{			Guys.unregister(this, destroy);		}		 	}}